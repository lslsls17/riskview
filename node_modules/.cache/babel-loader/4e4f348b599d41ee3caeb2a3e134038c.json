{"ast":null,"code":"const request = require('request');\n\nconst baseUrl = 'https://finance.yahoo.com/quote/';\n/**\n * @param {number} startMonth\n * @param {number} startDay\n * @param {number} startYear\n * @param {number} endMonth\n * @param {number} endDay\n * @param {number} endYear\n * @param {string} ticker\n * @param {('1d','1wk','1mo')} frequency\n * @param {Function} [callback]\n *\n * @return {Promise<{date: number, open: number, high:number, low:number, close:number, volume:number, adjclose:number}[]>|undefined} Returns a promise if no callback was supplied.\n */\n\nconst getHistoricalPrices = function (startMonth, startDay, startYear, endMonth, endDay, endYear, ticker, frequency, callback) {\n  const startDate = Math.floor(Date.UTC(startYear, startMonth, startDay, 0, 0, 0) / 1000);\n  const endDate = Math.floor(Date.UTC(endYear, endMonth, endDay, 0, 0, 0) / 1000);\n  const promise = new Promise((resolve, reject) => {\n    request(`${baseUrl + ticker}/history?period1=${startDate}&period2=${endDate}&interval=${frequency}&filter=history&frequency=${frequency}`, (err, res, body) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      try {\n        const prices = JSON.parse(body.split('HistoricalPriceStore\\\":{\\\"prices\\\":')[1].split(',\"isPending')[0]);\n        resolve(prices);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }); // If a callback function was supplied return the result to the callback.\n  // Otherwise return a promise.\n\n  if (typeof callback === 'function') {\n    promise.then(price => callback(null, price)).catch(err => callback(err));\n  } else {\n    return promise;\n  }\n};\n/**\n * @param {string} ticker\n *\n * @return {Promise<{price: number, currency: string}>}\n */\n\n\nconst getCurrentData = function (ticker) {\n  return new Promise((resolve, reject) => {\n    request(`${baseUrl + ticker}/`, (err, res, body) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      try {\n        let price = body.split(`\"${ticker}\":{\"sourceInterval\"`)[1].split('regularMarketPrice')[1].split('fmt\":\"')[1].split('\"')[0];\n        price = parseFloat(price.replace(',', ''));\n        const currencyMatch = body.match(/Currency in ([A-Za-z]{3})/);\n        let currency = null;\n\n        if (currencyMatch) {\n          currency = currencyMatch[1];\n        }\n\n        resolve({\n          currency,\n          price\n        });\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n};\n/**\n * @param {string} ticker\n * @param {Function} [callback]\n *\n * @return {Promise<number>|undefined} Returns a promise if no callback was supplied.\n */\n\n\nconst getCurrentPrice = function (ticker, callback) {\n  if (callback) {\n    getCurrentData(ticker).then(data => callback(null, data.price)).catch(err => callback(err));\n  } else {\n    return getCurrentData(ticker).then(data => data.price);\n  }\n};\n\nmodule.exports = {\n  getHistoricalPrices,\n  getCurrentData,\n  getCurrentPrice\n};","map":{"version":3,"sources":["C:/Users/lswht/OneDrive/material/GitHub/riskview/node_modules/yahoo-stock-prices/yahoo-stock-prices.js"],"names":["request","require","baseUrl","getHistoricalPrices","startMonth","startDay","startYear","endMonth","endDay","endYear","ticker","frequency","callback","startDate","Math","floor","Date","UTC","endDate","promise","Promise","resolve","reject","err","res","body","prices","JSON","parse","split","then","price","catch","getCurrentData","parseFloat","replace","currencyMatch","match","currency","getCurrentPrice","data","module","exports"],"mappings":"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","sourcesContent":["const request = require('request');\n\nconst baseUrl = 'https://finance.yahoo.com/quote/';\n\n/**\n * @param {number} startMonth\n * @param {number} startDay\n * @param {number} startYear\n * @param {number} endMonth\n * @param {number} endDay\n * @param {number} endYear\n * @param {string} ticker\n * @param {('1d','1wk','1mo')} frequency\n * @param {Function} [callback]\n *\n * @return {Promise<{date: number, open: number, high:number, low:number, close:number, volume:number, adjclose:number}[]>|undefined} Returns a promise if no callback was supplied.\n */\nconst getHistoricalPrices = function (\n    startMonth,\n    startDay,\n    startYear,\n    endMonth,\n    endDay,\n    endYear,\n    ticker,\n    frequency,\n    callback,\n) {\n    const startDate = Math.floor(Date.UTC(startYear, startMonth, startDay, 0, 0, 0) / 1000);\n    const endDate = Math.floor(Date.UTC(endYear, endMonth, endDay, 0, 0, 0) / 1000);\n\n    const promise = new Promise((resolve, reject) => {\n        request(`${baseUrl + ticker}/history?period1=${startDate}&period2=${endDate}&interval=${frequency}&filter=history&frequency=${frequency}`, (err, res, body) => {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            try {\n                const prices = JSON.parse(body.split('HistoricalPriceStore\\\":{\\\"prices\\\":')[1].split(',\"isPending')[0]);\n\n                resolve(prices);\n            } catch (err) {\n                reject(err);\n            }\n        });\n    });\n\n    // If a callback function was supplied return the result to the callback.\n    // Otherwise return a promise.\n    if (typeof callback === 'function') {\n        promise\n            .then((price) => callback(null, price))\n            .catch((err) => callback(err));\n    } else {\n        return promise;\n    }\n};\n\n/**\n * @param {string} ticker\n *\n * @return {Promise<{price: number, currency: string}>}\n */\nconst getCurrentData = function (ticker) {\n    return new Promise((resolve, reject) => {\n        request(`${baseUrl + ticker}/`, (err, res, body) => {\n            if (err) {\n                reject(err);\n                return;\n            }\n\n            try {\n                let price = body.split(`\"${ticker}\":{\"sourceInterval\"`)[1]\n                    .split('regularMarketPrice')[1]\n                    .split('fmt\":\"')[1]\n                    .split('\"')[0];\n\n                price = parseFloat(price.replace(',', ''));\n\n                const currencyMatch = body.match(/Currency in ([A-Za-z]{3})/);\n                let currency = null;\n                if (currencyMatch) {\n                    currency = currencyMatch[1];\n                }\n\n                resolve({\n                    currency,\n                    price,\n                });\n            } catch (err) {\n                reject(err);\n            }\n        });\n    });\n};\n\n/**\n * @param {string} ticker\n * @param {Function} [callback]\n *\n * @return {Promise<number>|undefined} Returns a promise if no callback was supplied.\n */\nconst getCurrentPrice = function (ticker, callback) {\n    if (callback) {\n        getCurrentData(ticker)\n            .then((data) => callback(null, data.price))\n            .catch((err) => callback(err));\n    } else {\n        return getCurrentData(ticker)\n            .then((data) => data.price);\n    }\n};\n\nmodule.exports = {\n    getHistoricalPrices,\n    getCurrentData,\n    getCurrentPrice,\n};\n"]},"metadata":{},"sourceType":"script"}